# Урок 8: Горутины и каналы

**Горутины** - обычные функции, которые выполняются конкурентно (в пересекающиеся моменты времени). Горутины
легковесные, у каждой из них свой стек, все остальное (память, файлы и т.п.) - общее. Запуск новой горутины
производится с помощью ключевого слова `go`. Горутина завершается когда происходит выход из функции или когда
завершается основная горутина (функция `main`). 

**Каналы** - тип (и механизм) в Go, предназначенный для синхронизации горутин и передачи данных между ними. Канал
работает по принципу FIFO (очередь).

```go
var c chan string           // Канал для передачи строк
var c chan int              // Канал не инициализирован, nil
var c = make(chan int)      // Канал инициализирован, ёмкость - 0
var c = make(chan int, 10)  // Ёмкость буфера 10 элементов
```

Каналы могут быть:
* на чтение / на запись / и то и другое
* буферизованными / небуферизованными
* открытыми / закрытыми

Запись в канал осуществляется оператором `<-` справа от канала, т.е. `ch <- value`:
```go
var ch = make(chan int, 10)
ch <- 42
```

Чтение из канала - также оператором `<-`, но слева от канала:
```go
i := <- ch        // получить данные из канала в переменную i
i, ok := <- ch    // получить данные и флаг открытости
<- ch             // получить и отбросить данные из канала
```

В один канал могут писать (и читать из него) несколько горутин.
**Важно!** Закрытый канал всегда будет возвращать данные - zero-value соответствующего типа.

Пример работы канала:
```go
func primeChecker(in chan int, out chan int) {
  for {
    i := <- in
    if isPrime(i) {
      out <- i
    }
  }
}

func main() {
  var inCh = make(chan int, 10)
  var outCh = make(chan int, 10)

  go primeChecker(inCh, outCh)
  go primeChecker(inCh, outCh)    // Можно распаралелить обработку
  
  go func() {
    for {
      fmt.Println(<- outCh)
    }
  }()

  for i := 0; i < 1000000; i++ {
    inCh <- i
  }
}
```

### Итерация по каналу
Значения из канала удобно получать в цикле с помощью `range`. Функции из примера выше можно переписать так:
```go
func primeChecker(in chan int, out chan int) {
  for i := range in {
    if isPrime(i) {
      out <- i
    }
  }
}

go func() {
  for j := range outCh {
    fmt.Println(j)
  }
}()
```

Основным отличием от предыдущего примера является то, что в первом случае внутри горутины цикл `for` будет крутиться
бесконечно, и горутина завершит свою работу только когда завершится `main()`. Поэтому из такого цикла нужно будет
выходить самостоятельно при закрытии канала. Во втором случает `range` аналогично будет вычитывать из канала значения,
но горутина завершится после того, как канал будет закрыт.

### Закрытие канала
Канал можно закрыть с помощью встроенной функции `close`. После закрытия канала:
1. чтение из него будет возвращать zero-value для типа канала
2. запись в него приведет к `panic`
3. итерация с помощью `range` прекратится
4. оператор `select` будет сразу всегда возвращать zero-value

```go
var in = make(chan int, 10)
go func() {
  for i:= range in {
    // ...
  }
}()

go func() {
  for {
    i, ok := <- in
    if !ok {
      return
    }
  }
}()

close(in)
```

**Best Practice:** Закрывать канал должна пишущая горутина, либо ее создатель.

Если после закрытия канала в нем остались еще какие-либо данные, то их получится считать до конца. А после того, как
они закончатся, начнет возвращаться соответствующий флаг о закрытии канала.

### Каналы на чтение и на запись
В Go есть возможность уточнить способ использования канала (чтение_запись), указав это при объявлении типа. Тип
_канал-на-чтение_ объявляется как `<-chan T`, _канал-на-запись_ как `chan<- T`:

```go
func primeChecker(in <-chan int, out chan<- int) {
  // из in можно только читать
  // в out можно только писать
}

var inCh = make(chan int, 10)
var outCh = make(chan int, 10)

primeChecker(inCh, outCh)   // Автоматическое преобразование типов
```

Формально `chan T`, `<-chan T` и `chan<- T` - различные типы данных, однако при присвоении (с уточнением) работает
автоматическое преобразование типа. В основном такие уточнения типов используются компилятором для проверки на ошибки.

### Пустые и полные каналы
Что произойдет если мы инициализируем канал и сразу попытаемся прочитать из него:
```go
var ch = make(chan int, 10)
i := <- ch
```
Чтение из канала заблокируется до тех пор, пока туда не попадут данные для чтения. В случае выше пустой и не закрытый
канал, который заблокируется навечно.

Что произойдет если мы инициализируем канал с буфером в 10 элементов, а потом попытаемся записать в него 20 элементов
(без чтения из него):
```go
var ch = make(chan int, 10)
for i := 0; i < 20; i++ {
  ch <- i
}
```
Первые 10 элементов будут успешно записаны, а потом мы остановимся до тех пор, пока кто-нибудь из него не вычитает данные.

### Буферизация канала
Запись в канал возможна, если есть горутина, вызвавшая операцию чтения из канала, либо есть место в буфере. И наоборот,
чтение возможно, если есть горутина, вызвавшая операцию записи, либо есть данные в буфере.

Основное назначение _буферизованных каналов_ - эффективный и неблокирующий обмен данными между горутинами. Проще говоря,
если с одним каналом работает несколько горутин, то наличие буфера позволит не заставлять ждать записи одной горутине,
пока данные не будут вычитаны другой горутиной.

```go
var ch = make(chan int, 10)
ch <- 1
ch <- 2
ch <- 3

fmt.Printf("Заполненность канала: %s\n", len(ch))
// Заполненность канала: 3

fmt.Printf("Размер канала: %s\n", cap(ch))
// Размер канала: 10
```

В чем разница между `make(chan int)` и `make(chan int, 1)`? Разница в том, что в первом случае возможно будет записать
в канал только в том случае, если его кто-то читает. Во втором случае можно будет записать в буфер один элемент
без читателя, а на втором элементе канал уже заблокируется.

### Конструкция select
Конструкция `select` позволяет одновременно читать/писать из нескольких каналов:

```go
var stop <-chan struct{}
var out1 chan<- interface{}
var out2 chan<- interface{}
// Каналы должны быть инициализированы ^^

select {
  case out1 <- value1:
    fmt.Println("Succeded to send to out1")
  case out2 <- value2:
    fmt.Println("Succeded to send to out2")
  case <- stop:
    fmt.Println("Manually stopped")
  default:
    fmt.Println("Nothing happens")
    time.Sleep(10 * time.Millisecond)
}
```

`select` пытается записать (получить) данные в доступные каналы, т.е. тот в котором есть место в буфере или ожидающая
горутина. Если не одна операция не возможна на данный момент, `select` блокирует выполнение текущей горутины. Внутри
себя `select` узнает у рантайма в каких каналах есть данные выбирает один из них рандомно. Поэтому он не гарантирует
прохождение по каждому `case` по порядку.

В конструкцию `select` можно добавить секцию `default`, которая будет выполнена если ни одна из операций с каналами
не может быть совершена в данный момент.

## Паттерны
### Отправка сигналов
Закрытие канала - один из способов "послать сигнал" горутине. Часто закрытие канала используют как сигнал на выход
из горутины или остановку чего-либо.

Например, мы хотим запустить 10000 горутин одновременно (примерно в одно и тоже время). Если их просто запускать в цикле,
то горутины уже начнут выполняться до того, как цикл дойдет до конца. А также цикл со временем начнет тормозить по мере
запуска новых горутин.

```go
var start = make(chan struct{})   // "барьер"
for i := 0; i < 10000; i++ {
  go func() {
    <- start
    // горутины не начнут работу
    // пока не будут созданы все 10000
    }()
}
close(start)
```

Создается небуферизованный канал типа `struct{}` (чтобы не занимал места). Все горутины запускаются и останавливаются
на первой строчке `<- start`, т.к. они не могут ничего записать в канал поскольку никто не читает из канала и горутины
ждут. После окончания цикла мы закрываем канал `close(start)` и все горутины продолжат свое исполнение.

### Функция-генератор
Генератор - функция, возвращающая последовательность значений. В Go - это функция возвращающая канал.

```go
func ReadDir(dir string) <-chan string {
  c := make(chan string, 5)
  go func() {
    f, err := os.Open(dir)
    if err != nil {
      close(c)
      return
    }

    names, err := f.Readdirnames(-1)
    if err != nil {
      close(c)
      return
    }

    for _, n := range names {
      c <- n
    }
    close(c)
  }()

  return c
}
```

### Таймауты и повторы
`time.Timer` - позволяет получить "уведомление" через указанное время. Например, мы хотим получать данные из канала `in`,
но не дольше чем 10 секунд:
```go
timer := time.NewTimer(10 * time.Second)
select {
  case data <- in:
    fmt.Printf("Received: %s", data)
  case <- timer.C:
    fmt.Printf("Failed to receive in 10s")
}
```

`time.Ticker` - позволяет получать "периодические уведомления".
```go
ticker := time.NewTicker(10 * time.Second)
OUT:      // Метка для цикла for
for {
  select {
    case <- ticker.C:
      fmt.Pringln("Do some job")
    case <- stop:
      break OUT     // выходит не из select, а из цикла for
  }
}
```

### Мультиплексирование
В Go можно слить два однотипных канала в один:
```go
func Merge(in1, in2 <-chan interface{}) <-chan interface{} {
  ret := make(chan interface{})
  go func() {
    for {
      select {
        case v := <- in1:
          ret <- v
        case v := <- in2:
          ret <- v
      }
    }
  }()
}
```

## Работа планировщика Go
Scheduling In Go:
* [Part I: OS Scheduler](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)
* [Part II: Go Scheduler](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html)
* [Part III: Concurrency](https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html)

[Google I/O 2012: Go Concurrency Patterns (Rob Pike)](https://youtu.be/f6kdp27TYZs)

### Факты о планировщике
* В Go не-вытесняющий планировщик (пока, но скоро будет наоборот), т.е. нет гарантии что планировщик заменит одну
горутину на другую. К примеру если в горутине внутри работает длительный цикл или рассчитывается какая-то математика.
Все операции что не указаны в списке ниже, не дадут планировщику сменить горутину.
* Передача управления планировщику при:
  - Системном вызове
  - Создании новой горутины
  - Работа с каналами / mutex и другой синхронизацией
  - Garbage Collection
  - Вызове `runtime.Gosched`
* Длинные циклы и вычисления не могут быть прерваны (пока), это может приводить к зависанию
* С помощью `runtime.GOMAXPROCS` можно указать доступное Go число ядер процессора

Статья о том, когда планировщик может перекидывать горутины на другие ядра процессора:
[Work-Stealing in Go Scheduler](https://medium.com/a-journey-with-go/go-work-stealing-in-go-scheduler-d439231be64d)

Хороший доклад об concurrency в Go:
[Как не ошибиться с конкурентностью в Go](https://habr.com/ru/company/avito/blog/466495/)

[<< Предыдущая](03-slices.md) | [Оглавление](../readme.md)
